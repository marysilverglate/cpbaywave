{
    "collab_server" : "",
    "contents" : "#' Change Point Detection\n#'\n#' This function creates a multi-dimensional time series with a possible change point in the mean.\n#' @param a The multi-dimensional time series. Each row is the value at a single time. Numerically unstable if data dimension is greater than about 50. Use JLDetectChangePoint in that case.\n#' @param setdetail The detail levels of the wavelet transform to use to detect change in mean. Default is all levels.\n#' @param useBFIC Set to true to choose the change point with highest BFIC.\n#' @param showplot Set to true to see a plot of the probabilities of a change point at each time.\n#' @return value The value of the BFIC or maximium probability if useBFIC = FALSE. BFIC greater than 3 is evidence that there is a change in mean.\n#' @return index A vector giving the 5 most likely (or highest IC if useBFIC is TRUE) indices where a change point occurred.\n#' @export\n#' @examples\n#' a <- createTimeSeries()\n#' detectChangePoint(a, 0:6)\n#'\n#'\n#' #Time series with no change in mean.\n#' dim=5\n#' sig1=diag(dim)\n#' mu1=rep(0,dim)\n#' mu2=rep(0,dim)\n#' n=128\n#' tau=70\n#' series=createTimeSeries(mu1, mu2, sig1, n, tau)\n#' plot(series[,1])\n#' dtl=c(0,1,2,3,4,5,6)\n#' detectChangePoint(series,dtl)\n#' #value less than 3 indicates no change model is favored\n#'\n#'\n#' #Time series with smooth mean function with jump.\n#' dim=10\n#' sig1=diag(dim)\n#' mu1=rep(0,dim)\n#' mu2=rep(1.5,dim)\n#' n=90\n#' tau=20\n#' series1=createTimeSeries(mu1, mu2, sig1, n, tau)\n#' sn=sin(2*pi*1:n/n)\n#' series2=sn+series1\n#' plot(series2[,2])\n#' dtl=c(0,1,2,3,4,5)\n#' detectChangePoint(series2,dtl, useBFIC = TRUE)\n#' #value greater than 3 indicates change model is favored\n#' detectChangePoint(series2,dtl)\n#'\n#'\n#' #Time series with smooth mean function, no jump\n#' dim=3\n#' sig1=diag(dim)\n#' mu1=rep(0,dim)\n#' mu2=rep(0,dim)\n#' n=256\n#' tau=105\n#' series1=createTimeSeries(mu1, mu2, sig1, n, tau)\n#' sn=sin(2*pi*1:n/n)\n#' series2=sn+series1\n#' plot(series2[,2])\n#' dtl=c(0,1,2,3,4,5)\n#' detectChangePoint(series2,dtl)\n#' #value less than 3 indicates no change-model is favored\n\n\n\ndetectChangePoint <- function(a, setdetail, useBFIC = TRUE, showplot = FALSE) {\n\n    if(ncol(a) > 100) stop(\"dimension too high. consider JLdetectChangePoint\")\n\n    if(missing(setdetail)) setdetail <- 0:floor(log2(nrow(a) - 1))\n    F <- 10\n    n <- nrow(a)\n    wid <- ncol(a)\n\n    if(wid > 50) warning(\"This computation is likely numerically unstable. Consider JLdetectChangePoint instead.\")\n\n\n    # pad with normal data at top of a, centered at first element of time series\n    nxt <- 2^(ceiling(log2(n)))\n    pad1 <- nxt - n\n    data <- a\n    #Padding by extending first entry + some noise.\n    #data <- rbind(matrix(stats::rnorm(pad1 * wid, a[1,], 0.1), ncol = wid), a)\n\n    #Trying mirror padding. Seems better based on simulations.\n    if(pad1 > 0) data <- rbind(a[pad1:1,], a)\n\n    # re-establish length\n    n <- nxt\n\n    # Get information about wd, could be improved\n    genDWT <- (wavethresh::wd(data[, 1], filter.number = F, family = \"DaubExPhase\"))  #generic DWT\n    p <- wavethresh::nlevelsWT(genDWT)\n    J <- p\n\n    # Compute details of discrete wavelet transform of data by column and store desired details in DWTmat TODO: write\n    # wrapper for accessD that pulls out multiple levels and returns a vector of details unlist(sapply(...)) pulls out\n    # the desired levels of detail coefficients and combines them in a vector\n    DWTmat <- apply(data, 2, function(x) unlist(sapply(J - setdetail - 1, function(y) wavethresh::accessD(wavethresh::wd(x,\n        filter.number = F, family = \"DaubExPhase\"), y))))\n\n    # Creating idealized data set and its discrete wavelet transform Have 0's followed by 1's with change point in each\n    # possible position\n    probvec <- sapply(1:(n - 1), function(x) {\n        tauvec <- c(rep(0, x), rep(1, nxt - x))\n        Qvec <- unlist(sapply(J - setdetail - 1, function(y) wavethresh::accessD(wavethresh::wd(tauvec, filter.number = F,\n            family = \"DaubExPhase\"), y)))\n        computeProb(DWTmat, Qvec, useBFIC)\n    })\n\n    if (showplot)\n        graphics::plot(probvec, type = \"l\")\n\n    # If M1 > 3, good evidence of change point\n    M2 = max(probvec)\n    m <- nrow(DWTmat)\n    t1 = gamma(m/2 + 0.5)\n    A <- t(DWTmat) %*% DWTmat\n    t2 = det(A)  #Numerically unstable.\n    M1 = log(t1) + (-m/2 + wid/2) * log(t2)\n\n\n    ifelse(useBFIC, value <- (M2 - M1 - 0.5 * wid * log(m)), value <- max(probvec))\n\n    # Remove nan and return the 5 most likely change points There shouldn't be nan, maybe rather exit with error if\n    # there are?\n    probvec[is.nan(probvec)] <- min(probvec)\n\n    indices <- match(utils::head(sort(probvec, decreasing = TRUE), 5), probvec)\n\n    return(list(value = value, index = indices - pad1))\n}\n",
    "created" : 1488055529391.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1133683139",
    "id" : "4BDE7BF0",
    "lastKnownWriteTime" : 1488055838,
    "last_content_update" : 1488055838023,
    "path" : "~/Documents/cpbaywave/R/changePointDetect.R",
    "project_path" : "R/changePointDetect.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}